# 솔라나 트랜잭션

본 아티클은 Blockchain at Yonsei가 Helius의 솔라나 리포트를 기반으로 솔라나의 트랜잭션 메커니즘을 6단계로 분석했습니다. 

**1\. 개요**

솔라나(Solana)는 초당 수천 건의 트랜잭션(TPS)을 처리할 수 있는 **고성능, 고처리량 블록체인**입니다. 기존 블록체인들이 처리 속도가 느리고 수수료가 비싼 반면, 솔라나는 **매우 빠른 트랜잭션 처리 속도와 낮은 수수료**를 제공합니다. 

기존 블록체인의 속도를 지연시키는 주요 요인 중 하나는 **멤풀(mempool)**이라는 ‘거래 대기실’인데, 솔라나는 이 멤풀을 완전히 제거하고 더 표율적인 네트워크 프로토콜을 도입하여 속도와 효율성을 극대화했습니다. 

이 글에서는 **Helius**의 6단계 프레임워크를 사용해 솔라나의 **트랜잭션 처리 워크플로우**를 설명하며, 트랜잭션이 어떻게 **캡처되고, 우선순위가 정해지며, 전송되는지** 구체적으로 다룹니다.

# **2\. 솔라나 트랜잭션 생애 주기의 6단계**

**![][image1]**

## **2.1 사용자 및 트랜잭션 제출**

솔라나 트랜잭션은 **사용자**로부터 시작되며, 사용자는 지갑이나 애플리케이션을 이용해 트랜잭션을 생성하고 서명합니다. 이 과정에서 사용자는 **솔라나 RPC(Remote Procedure Call) 노드**와 상호작용합니다. RPC 노드는 사용자와 솔라나 블록체인 사이에서 통신 다리 역할을 하는 중개자 서버입니다. 사용자가 지갑이나 앱을 통해 트랜잭션을 생성하는 등의 활동을 할 때, 해당 요청을 받아서 블록체인 네트워크에 전달하고, 결과를 다시 사용자에게 돌려줍니다.

## **트랜잭션 생성 방법**

**![][image2]**

사용자는 자신의 **Ed25519 개인 키(private key)** 로 트랜잭션에 서명합니다.

각 트랜잭션은 다음 내용을 포함합니다:

* **헤더(Header)**: 해당 트랜잭션에 서명해야 하는 계정(서명자)을 명시합니다.  
* **계정 주소(Account Addresses)**: 트랜잭션에서 데이터를 읽거나 변경할 계정들의 목록입니다.  
* **최근 블록해시(Recent Blockhash)**: 최근에 생성된 블록의 해시값으로, 동일한 트랜잭션이 반복 실행되는 리플레이 공격(Replay Attack)을 방지합니다.  
* **명령어(Instructions)**: 온체인 프로그램을 호출하여, 어떤 작업을 수행할지 구체적으로 지시합니다.

## **RPC 노드를 통한 트랜잭션 제출**

* 사용자가 지갑이나 앱을 통해 트랜잭션을 작성하고, 이를 RPC 노드에 보냅니다. RPC 노드는 해당 요청을 블록체인 네트워크에 전달하는 역할을 합니다.  
* 사용자는 **우선순위 수수료(Priority Fees)**라는 추가 비용을 지불해 자신의 트랜잭션이 더 빨리 처리되도록 요청할 수 있습니다.  
* RPC 노드는 트랜잭션을 실제로 네트워크에 보내기 전에 **모의 실행(simulate)**하여 해당 트랜잭션의 유효성을 확인합니다. 이를 통해 트랜잭션이 정상적으로 처리될 수 있는지, 오류가 없는지 미리 확인할 수 있습니다. (이 기능은 기본적으로 활성화되어 있으며, *skipPreflight* 옵션이 **false**일 때 동작합니다.)

## **2.2 걸프 스트림(Gulf Stream): 멤풀(Mempool)이 없는 트랜잭션 전달**

## **멤풀(Mempool) 이란?**

멤풀은 기존 블록체인(비트코인, 이더리움)에서 트랜잭션이 처리되기 전 일시적으로 대기하는 메모리 공간입니다. 사용자의 거래가 블록에 포함되어 ‘확인(confirm)’되기 전까지 ‘미확인’ 상태로 멤풀에 저장됩니다. 각 노드가 자신만의 멤풀을 가지고 있으며, 채굴자/검증자가 멤풀에서 대기중인 트랜잭션 중 일부를 선택해 블록에 포함시킵니다. 

트랜잭션이 멤풀에 오래 머무를수록 네트워크 혼잡이 발생하며, 사용자들이 자신의 트랜잭션을 빨리 처리 받기 위한 수수료 경쟁이 치열해진다는 문제점이 있습니다.

**솔라나의 걸프 스트림![][image3]**

솔라나는 이러한 대기실(멤풀)을 완전히 제거했습니다. 대신, “걸프 스트림(Gulf Stream)”이라는 시스템을 도입했습니다. 걸프 스트림은 네트워크 상의 노드가 트랜잭션을 수신한 시점부터, 해당 트랜잭션이 현재 슬롯의 리더(leader)에게 전달되어 TPU(Transaction Processing Unit, 트랜잭션 처리 장치)의 Fetch 단계에 도달하기까지의 과정을 지칭합니다.

이 시스템은 트랜잭션을 대기시키지 않고 **미리 정해진 미래 블록 생성자(슬롯의 리더)에게 직접 전송**하여 트랜잭션을 “대기 없이” 빠르고 안전하게 처리합니다. 이를 통해 네트워크 혼잡과 트랜잭션 확인 시간을 현저히 줄일 수 있습니다.

## **리더 노드(Leader Node)의 역할**

리더는 특정 시간 동안(약 0.4초, ‘슬롯’이라 지칭) 블록을 생성할 권한을 가진 검증자입니다. 미리 2일 단위(에포크)로 어떤 검증자가 언제 리더가 될지 리더 스케줄이 정해지고, 이는 모든 검증자가 공유합니다. 리더는 자신의 슬롯 시간에 트랜잭션을 처리하고 블록을 생성한 후, 다음 리더에게 차례를 넘깁니다.

## **멤풀 제거 \- 트랜잭션 처리 방식**

* **직접 전송 시스템**: 트랜잭션을 멤풀에서 대기시키는 과정 없이, 걸프 스트림은  트랜잭션을 다음 슬롯의 리더(Leader)에게 즉시 전송합니다. 이를 통해 검증자(Validator)가 많은 양의 트랜잭션을 장기 저장할 필요가 없어 메모리 사용량을 줄이며, 프론트러닝 (front-running)과 스팸 공격을 효과적으로 억제합니다.  
* **자동 만료 시스템**: 모든 트랜잭션 메시지는 최근의 블록해시(recent blockhash)를 포함해야 하며, 이는 약 150 슬롯(대략 1분) 동안만 유효합니다. 150 슬롯이 지나면 블록해시가 만료되고, 만료된 트랜잭션은 네트워크에서 자동 삭제되어 오래된 데이터가 쌓이지 않습니다.

## **트랜잭션 전달 과정 (예시)**

1. 솔라나는 미리 정해진 리더 스케줄에 따라 향후 슬롯의 블록 생성자를 지정합니다.  
2. 사용자가 트랜잭션을 생성하면, 이를 RPC 노드 (혹은 검증자 노드)에 전송합니다.  
3. RPC 노드는 다음 슬롯 리더를 확인해 트랜잭션을 **직접 전달(forward)** 합니다.  
4. 리더는 트랜잭션을 검증한 후, 블록에 포함시킵니다.  
5. 1분 내에 처리되지 않은 트랜잭션은 자동으로 삭제됩니다.

## **UDP에서 QUIC로의 전환**

초기에 솔라나(Solana)는 네트워크 프로토콜로 **UDP** 를 사용했습니다. UDP는 연결을 설정하지 않고 데이터를 보내는 방식으로 속도가 빠르지만 다음과 같은 문제점을 겪었습니다:

![][image4]

* 연결 지향이 아니며 흐름 제어나 패킷 수신 확인이 부족합니다. 즉, 데이터가 제대로 도착했는지 확인하지 않고, 네트워크가 혼잡해도 전송 속도를 조절하지 못합니다.  
* 누가 얼마나 많은 데이터를 보내는지 제한하거나, 악의적인 행동(캔디머신 스팸 공격)을 방지/완화할 실질적인 방법이 없습니다.

이후 구글(Google)이 개발한 **QUIC** 으로 프로토콜을 전환하면서 다음과 같은 개선점을 얻게 되었습니다:

![][image5]

* **혼잡 제어(Congestion Control)**: 트랜잭션 유실을 최소화합니다.  
* **신뢰성(Reliability)**: 패킷 손실을 줄여 통신 품질을 향상합니다.  
* **보안성(Security)**: 암호화된 채널로 공격 가능성을 낮춥니다.

QUIC의 도입으로 인해 솔라나 네트워크의 **안정성과 신뢰성이 향상되었습니다**. 그러나 이러한 개선에도 불구하고 QUIC 구현이 솔라나에서 얼마나 효과적인지에 대해서는 여전히 논의가 진행 중입니다.

## **지분 가중 서비스 품질 (SWQoS, Stake-Weighted Quality of Service)**

**![][image6]**

## **솔라나에서 SWQoS의 작동 방식**

지분 가중 서비스 품질(SWQoS)은 솔라나 코인(SOL)을 더 많이 스테이킹한 검증자(validator)에게 더 높은 트랜잭션 처리 우선순위를 부여하는 시스템입니다. 더 많은 SOL을 스테이킹한 검증자들은 더 많은 동시 접속(stream)을 확보하게 되어, 혼잡 상황에서도 중요한 트랜잭션이 누락되지 않도록 보장받습니다.

솔라나 네트워크에는 총 2,500개의 연결 채널이 있습니다:

* 500개: 모든 RPC 노드가 사용할 수 있는 일반 채널.  
* 2,000개: 스테이킹한 검증자만 사용 가능한 지분 가중 연결.

각 검증자는 스테이킹한 지분 비율에 따라 이 연결을 배분받습니다.  
즉, 지분이 높은 검증자는 더 많은 스트림을 열 수 있어 더 많은 트랜잭션 부하를 처리할 수 있습니다.

또한, TPU 시스템에서는 각 연결(스트림)마다 초당 허용 패킷 수(Packets Per Second, PPS)를 지분 비율에 따라 제한(rate limiting)합니다. 따라서, 지분이 없는 노드는 매우 낮은 PPS 제한이 적용되어, 네트워크에 미치는 영향이 미미합니다.

**차이점: SWQoS vs 우선순위 수수료(Priority Fees)**

* **SWQoS:**  네트워크가 혼잡할 때 지분(스테이킹)이 많은 검증자가 트랜잭션을 더 쉽게, 더 많이 네트워크에 보낼 수 있도록 빠른 전용 통로(마치 VIP 전용 입구와 같음)를 제공하는 시스템입니다.  즉, 트랜잭션이 네트워크에 잘 들어가도록 ‘네트워크 입구에서의 우선권’을 보장합니다. 트랜잭션이 실제로 블록에 언제 포함될지는 SWQoS가 결정하지 않습니다.   
* **우선순위 수수료:** 트랜잭션이 이미 리더의 큐(queue)에 들어온 후, 수수료를 더 많이 낸 트랜잭션이 먼저 처리되도록 순서를 결정하는 시스템입니다. 즉, 블록 안에 어떤 트랜잭션이 먼저 들어갈지를 결정합니다.

**장단점**

* **향상된 사용자 경험(Enhanced UX)**: SWQoS 덕분에 사용자 입장에서는 네트워크가 혼잡할 때도 트랜잭션이 신속히 처리됩니다.  
* **진입 장벽(Barriers to Entry)**: SWQoS가 지분이 높은 검증자에게 더 많은 대역폭과 동시성을 제공하기 때문에, 소규모 또는 독립적인 검증자가 네트워크 참여시 진입 장벽이 높아질 수 있습니다.  
* **신뢰 기반 가정(Trust Assumptions)**: RPC 노드는 스테이킹되지 않고, 투표권도 없으며, 합의(consensus)에도 참여하지 않으므로, SWQoS의 혜택을 직접적으로 받을 수 없습니다. 따라서 SWQoS의 혜택을 최대한 활용하려면 검증자와 RPC 노드 간에 신뢰 관계가 형성되어야 합니다.

## **2.3 블록 생성(Block-Building): TPU 및 실행(Execution)**

**![][image7]**

**TPU**(트랜잭션 처리 장치, Transaction Processing Unit) 는 솔라나(Solana)의 **블록 생산 엔진**입니다. 초당 수만 건의 트랜잭션을 효유럭으로 처리하기 위해 여러 단계로 나뉘어 병렬적으로 작동합니다:

**1\. Fetch Stage/QUIC Streamer: 네트워크로 들어오는 트랜잭션 패킷 수집**

* 패킷 메모리 할당: QUIC 프로토콜을 통해 수신된 트랜잭션 패킷을 받아 메모리에 임시 저장합니다.  
* 패킷 병합: 동시에 도착한 여러 패킷을 하나의 트랜잭션으로 병합합니다.  
* PPS 제한 적용: SWQoS에 따라 초당 패킷 전송량(PPS)을 제한합니다. 지분이 높은 검증자는 더 많은 패킷을 전송할 수 있습니다.

**2\. 서명 검증 단계(Sig Verify Stage): 트랜잭션 유효성 검증**

* 중복 제거: 중복된 트랜잭션을 제거합니다.  
* 부하 분산 (Load-Shedding): 네트워크가 과부하 상태일 때, 일부 과도한 패킷을 제거하여 네트워크 부하를 줄입니다다.  
* 서명 검증: 트랜잭션 서명의 진위성을 확인하고, 잘못된 서명의 패킷은 폐기합니다.

**3\. 뱅킹 단계(Banking Stage): 트랜잭션 실행 및 블록 구성**

* 트랜잭션 처리 결정: 트랜잭션을 다른 리더에게 전달(Forward)할지, 보류(Hold)할지, 처리(Process)할지를 결정합니다.  
* 검증자가 현재 리더(Leader)라면, 대기 중이거나 새로 들어온 트랜잭션을 현재 슬롯에서 처리합니다다.  
* 후보 블록(candidate block)을 구성합니다.

**4\. 브로드캐스트 단계(Broadcast Stage): 완성된 블록을 네트워크에 전파**

* 슈레드(Shred) 생성: 검증된 트랜잭션을 **엔트리(entries)**로 변환하고, 이를 **슈레드(shreds)**로 패키징합니다**.** 이는 마치 대형 파일을 ZIP으로 압축해 분할 전송하는 것과 같습니다.  
* 슈레드를 직렬화(serialization), 서명(sign), 인코딩(encode)한 후 **터빈(Turbine)** 프로토콜을 통해 모든 검증자에게 빠르게 전파합니다.

이처럼 솔라나 TPU는 패킷 수집 \> 검증 \> 실행 \> 전파 단계를 거쳐 높은 트랜잭션 부하를 관리하며, 트랜잭션의 진위성을 검증하고 예정된 스케줄에 따라 블록을 생성합니다. 병렬 처리 방식과 지분 가중(stake-weighting) 시스템, QUIC 프로토콜 등을 결합하여 일관되게 높은 처리 성능능을 제공합니다.

## **뱅킹 단계(Banking Stage) 세부 설명**

**뱅킹 단계(Banking Stage)**는 트랜잭션을 실제 블록으로 만드는 TPU의 핵심 단계입니다. 검증자가 수신된 트랜잭션을 어떻게 처리할지 결정하고 후보 블록(candidate block)을 생성합니다.

**1\. 패킷 처리 방식 결정(Determining Packet Treatment)**

* **전달(Forward)**: 검증자가 현재 리더가 아닌 경우, 블록을 생산할 예정인 다음 슬롯의 리더에게 트랜잭션을 전달합니다.  
* **보류(Hold)**: 검증자가 다음 슬롯의 리더가 될 예정이라면 트랜잭션을 일시적으로 대기 상태로 유지합니다.  
* **처리(Process)**: 검증자가 현재 슬롯의 리더라면 이 트랜잭션을 실행해 Bank 상태를 업데이트합니다.

**2\. 뱅크 통합(Bank Integration)**

* “뱅크(Bank)”는 솔라나 블록체인에서 현재 슬롯의 원장(ledger) 상태를 나타내는 일종의 스냅샷(snapshot)입니다. 모든 계정의 잔액, 상태, 데이터 등이 어떤 상태인지지를 보여주는 “실시간 장부” 역할을 합니다.   
* 성공적으로 처리된 트랜잭션은 뱅크 상태(잔액, 계정 데이터 등)를 업데이트하여 다음 블록의 기초를 형성합니다.

**3\. 병렬 실행(Parallel Execution)**

* 병렬 실행은 트랜잭션을 하나씩 차례로 처리하는 것이 아니라, 동시에 여러 개를 처리함을 의미합니다.  
* 충돌 없는 트랜잭션: 상호 충돌이 없는(non-conflicting) 트랜잭션을 64개씩 하나의 엔트리(entry)로 묶어 동시에 처리합니다.  
* 충돌(conflict)이 있는 트랜잭션: 별도의 엔트리로 분리하여 순차적으로 실행합니다.

**4\. 검증 및 블록 조립(Validation and Block Assembly)**

* 유효하지 않은 트랜잭션(서명 오류, 자금 부족 등)은 폐기됩니다.  
* 검증된 트랜잭션은 Accounts DB에 기록됩니다.  
* 리더 슬롯이 끝나면, 생성된 블록은 최종 조립되어 네트워크에 전파됩니다.

이 과정을 통해 솔라나는 많은 트랜잭션을 동시에 효율적으로 병렬 처리하며, 계정 기반의 상태(Account-based state)를 신속하고 정확하게 관리합니다.

## **2.4 터빈(Turbine)을 이용한 블록 전파**

블록이 구축되면 Turbine을 통해 네트워크의 모든 참여자에게 전파될 준비가 됩니다. 이 과정을 **블록 전파**라고 합니다.

![][image8]

## **터빈(Turbine)의 핵심 원리**

터빈은 솔라나의 **블록 전파 프로토콜**입니다. 모든 노드에 전체 블록을 한번에 보내는 대신, 더 효율적인 방법을 사용합니다.

![][image9]

1. **슈레딩(Shredding): 블록 분할**
   리더 노드는 블록 데이터를 MTU 크기(Maximum Transmission Unit)의 데이터 슈레드로 분할하고 해당 복구 슈레드를 생성합니다.
2. **삭제 부호화(Erasure Coding): 데이터 복구 메커니즘**
* Reed-Solomon 삭제 코드를 사용하여, 슈레드에 패리티(parity) 정보를 가진 중복 패킷(redundant packet)을 생성합니다.
* 패킷 손실 또는 지연 도착 시에도 검증자는 패리티 정보를 통해 손실된 데이터를 복구할 수 있습니다.
* 솔라나는 32:32의 FEC(Forward Error Correction) 비율을 사용합니다. 이는 64개 패킷 중 최대 32개가 손실되어도 재전송 없이 복구 가능함을 의미하며, 약 99%의 전송 성공률을 제공합니다. 리더는 블록 전파 성공 확률을 높이기 위해 FEC 비율을 조정할 수 있습니다.
3. **터빈 트리 구조(Turbine Tree): 효율적 전파**
   터빈은 검증자 간에 효율적으로 데이터를 전달하기 위한 트리(Tree) 기반의 프로토콜을 사용합니다.

![][image10]

전달 과정은 다음과 같습니다.

* **목록 생성(List Creation)**: 네트워크의 모든 검증자들이 지분(stake)에 따라 정렬됩니다. 이 때 지분이 높은 검증자들이 더 빨리 데이터를 수신하도록 우선순위가 부여됩니다.  
* **목록 셔플링(List Shuffling)**: 정렬된 검증자 목록은 슬롯 리더(slot leader)의 ID, 슬롯 번호, 슈레드 인덱스(슈레드 번호) 등을 기반으로 하는 시드(seed)를 이용해 결정론적으로 무작위로 섞이며, 데이터 전송이 더욱 효율화됩니다. \- 이때 “결정론적으로 섞인다”는 것은, 섞는(셔플) 방법이 완전한 무작위(random)가 아니라, 정해진 규칙과 입력값(예: 시드 값, 슬롯 리더 ID, 슬롯 번호, 슈레드 인덱스 등)에 따라 항상 똑같은 결과를 내는 것을 의미합니다. 이는 네트워크의 모든 노드가 독립적으로 셔플을 해도, 동일한 입력값만 알면 똑같은 섞인 결과를 얻을 수 있게 합니다.  
* 계층 형성: 셔플된 목록은 DATA\_PLANE\_FANOUT(현재 200으로 설정됨)이라는 매개변수를 기반으로 계층적 트리 구조로 배치됩니다. 한 노드가 하위 노드에게 데이터를 전달하는 방식을 통해 빠른 전파가 보장되며, 일반적으로 모든 검증기에 도달하는 데 2\~3개의 홉(리더 → 루트 → 계층 1 → 계층 2)만 필요합니다.

현재 터빈은 블록 전파에 UDP 프로토콜을 사용하여 매우 낮은 지연시간(latency)을 제공합니다.

## **기존 가십(Gossip) 방식 대비 장점**

1. **확장성(Scalability)**: 트리 기반의 데이터 분산으로 단일 노드에 과도한 부하가 발생하지 않습니다.
2. **지연 감소(Latency Reduction):** 병렬식 데이터 전달로 블록 데이터가 빠르게 전파되고 확인됩니다.
3. **무결성 보장(Data Integrity):** 삭제 부호화와 재전송 메커니즘을 통해 패킷 손실 시에도 데이터를 효율적으로 복구할 수 있어 데이터 무결성을 보장합니다.
4. **대역폭 효율성(Bandwidth Efficiency):** 각 노드가 중복 없이 필요한 최소한의 데이터만 처리하므로 네트워크 대역폭을 효율적으로.사용합니다.

## **고처리량 구조에서 터빈(Turbine)의 역할**

* **빠른 블록 배포(Fast Block Propagation)**로 글로벌 검증자 간 신속한 블록 검증이 가능합니다.
* 새로운 리더로의 **빠른 리더 전환(Quick Leader Transition)**을 지원해, 다음 슬롯의 리더가 효율적으로 데이터를 수신할 수 있게 합니다.

결론적으로 터빈은 솔라나가 높은 성능과 확장성을 갖춘 블록체인으로 작동할 수 있도록 핵심적인 역할을 수행합니다.

## **2.5 트랜잭션 검증 장치(TVU)를 이용한 검증**

**![][image11]**

터빈(Turbine)을 통해 블록이 전파되면, **트랜잭션 검증 장치(Transaction Validation Unit, TVU)** 가 블록의 정확성을 다음과 같은 절차로 검증합니다.

1. **슈레드 재구성(Shred Reconstruction)**: 블록은 슈레드라는 데이터 조각으로 분할되어 네트워크에 전파되며, TVU는 이 조각들을 조합하여 원본 블록을 복원합니다.
2. **상태 검증(State Verification)**: 복원된 블록의 계정 잔액, 스마트 컨트랙트 상태, 이전 상태와의 일관성을 검증합니다.
3. **실행 재현(Execution Replay)**: 트랜잭션을 독립적으로 다시 실행(replay)하여 결과값이 블록에 기록된 결과와 일치하는지 확인합니다.
4. **투표 메커니즘(Voting Mechanism)**: 검증된 블록을 **Tower BFT** 합의 메커니즘을 통해 투표하고, 암호학적으로 서명하여 네트워크 합의에 참여합니다.

이러한 검증 단계를 통해 TVU는 각 블록의 정확성과 일관성을 보장하여 원장(ledger)의 무결성을 유지합니다.

## **2.6 합의(Consensus): 투표(Voting) 및 포크(Fork) 해결**

솔라나는 **지분 증명(PoS)** 과 **Tower BFT** 를 통해 **빠른 최종 확정성(fast finality)** 을 달성합니다:

**1\. Tower BFT 및 블록 최종 확정(Finalization)**

* **지분 증명(PoS) 기반:** Tower BFT는 솔라나 블록체인의 합의 알고리즘으로, 검증자(Validator)들은 스테이킹한 지분량에 비례하여 블록에 대한 투표권을 얻습니다.
* 네트워크 지분의 66% 이상(supermajority)이 동의하면 블록이 최종 확정됩니다.
* **락아웃(lockouts) 메커니즘:** 특정 블록에 투표한 후 일정 기간 다른 포크의 블록에 투표할 수 없도록 제한하는 메커니즘으로, 검증자의 포크 선택 변경을 제한하여 네트워크 안정성을 높입니다.

**2\. 포크 처리 및 체인 선택(Fork Handling & Chain Selection)**

**![][image12]**

* 경쟁하는 블록이 제안되면 블록체인이 여러 갈래(포크)로 분기될 수 있습니다.
* 검증자는 **PoH(Proof of History) 타임스탬프**(각 블록에 기록된 시간 정보를 기준으로 가장 오래된 포크 선택)와 **지분 가중 투표**(stake-weighted voting, 지분이 많은 검증자의 투표에 더 높은 가중치 부여)를 통해 가장 무거운(heavy) 체인을 선택합니다.
* 선택되지 않은 포크는 폐기되며, 해당 포크에만 포함된 트랜잭션은 다시 제출되어야 합니다.

솔라나는 지분 증명과 Tower BFT를 결합하여 **검증자 네트워크가 빠르게 블록을 확정**함으로써 높은 처리량(throughput)을 지속적으로 유지합니다.

# **3\. 트랜잭션 드롭(Drop)의 원인**

솔라나에서 트랜잭션이 실패하거나 드롭(사용자 지정 프로그램 에러나 잘못된 명령어 제외)되는 주요 원인은 다음과 같습니다:

**1\. 네트워크 드롭(Network Drops)**

* UDP 패킷 손실 또는 네트워크 혼잡으로 인해 트랜잭션이 드롭될 수 있습니다.
* 네트워크 부하가 과도할 경우, 검증자는 트랜잭션 전달 한계(초당 10,000개)를 초과할 수 있으며, 이 한계를 초과한 트랜잭션은 다른 검증자에게 전달되지 않고 드롭됩니다.

**2\. 오래되었거나 잘못된 블록해시(Stale or Incorrect Blockhash)**

* 트랜잭션은 타임스탬프 기능과 순서 지정을 위해 **최근 블록해시**를 포함합니다.
* 검증자는 제공된 블록해시가 유효하지 않거나 현재 상태와 일치하지 않으면 해당 트랜잭션을 거부합니다.

**3\. 만료된 블록해시(Expired Blockhash)**

* 블록해시는 약 **151 슬롯(약 1분 19초)** 이후에 만료됩니다.
* 만료된 블록해시를 참조하는 트랜잭션은 검증자에 의해 자동으로 거부됩니다.

**4\. 지연된 RPC 노드(Lagging RPC Nodes)**

* RPC 노드 풀(pool)이 일시적으로 최신 상태와 동기화되지 않을 수 있습니다.
* 최신 상태의 노드에서 가져온 블록해시를 사용하는 트랜잭션이 지연된 노드로 전송되면 거부될 수 있습니다.

**5\. 임시 네트워크 포크(Temporary Network Forks)**

* 일부 검증자의 지연으로 인해 임시 포크(fork)가 발생할 수 있습니다.
* 소수의 검증자만 인식하는 포크에서 가져온 블록해시를 사용한 트랜잭션은 네트워크가 다른 포크를 선택할 때 드롭될 수 있습니다.

이러한 시나리오를 이해하는 것은 솔라나 네트워크에서 트랜잭션 문제를 진단하고 해결하는 데 필수적입니다.

## **해결 방법(Workarounds)**

**1\. 트랜잭션 재전송(Resubmit Transactions)**

* 트랜잭션을 전략적으로 재전송하여 블록에 포함될 확률을 높일 수 있습니다.

**2\. 지분 가중 서비스 품질(SWQoS)**

* 지분이 있는(Staked) RPC 연결(예: **Helius**, **Triton**)을 이용하면 더 높은 우선순위와 성공률로 트랜잭션을 처리할 수 있습니다.

**3\. Jito MEV 인프라**

* Jito Block Engine을 활용하고 적절한 Jito 팁(tips)을 지불하면, 트랜잭션이 우선적으로 처리될 뿐 아니라 MEV 보호, 번들링(bundle) 처리, 원자적 실행 보장 등을 통해 솔라나 네트워크에서 최적화된 트랜잭션 처리를 보장할 수 있습니다.

**4\. 대체 MEV 인프라(Alternative MEV Infrastructure)**

* 블록체인에서 빠르게 데이터를 전송하도록 네트워크를 최적화한 전문 서비스(예: **bloXroute**, **Temporal/Nozomi**, **NextBlock**)를 이용하여 트랜잭션 처리 효율성을 높일 수 있습니다.

# **4\. Jito**

Jito는 솔라나(Solana) 블록체인의 **검증자 클라이언트의 확장 버전**으로, **최대 추출 가능 가치(Maximal Extractable Value, MEV)** 를 효과적으로 포착하고 공정하게 분배하기 위해 개발된 인프라입니다. Jito는 솔라나의 표준 검증자에 특화된 온체인 및 오프체인 컴포넌트를 추가하여 수익성을 향상시키고, 블록 공간을 최적화하며, MEV 수익을 검증자와 스테이커(staker) 간 공정하게 분배합니다.

Jito의 주요 구성요소는 다음과 같습니다:

* **오프체인 컴포넌트(Off-chain components)**: Relayer, Block Engine  
* **온체인 프로그램(On-chain programs)**: Tip Payment Program, Tip Distribution Program  
* **특화된 검증자 파이프라인**: BundleStage

## **주요 컴포넌트 및 아키텍처**

**1\. Jito-Solana 검증자**

* MEV 번들 처리를 위한 특화된 파이프라인 구현: **RelayerStage**, **BlockEngineStage**, **BundleStage**
* 번들의 검증, 시뮬레이션, 원자적(atomic) 실행을 담당합니다.

**2\. Relayer**

* 트랜잭션 진입점으로서 게이트웨이 역할을 수행합니다.
* MEV 번들 형성을 위해 트랜잭션을 약 200ms 동안 버퍼링합니다.
* gRPC 프로토콜을 통해 통신하여 병목 현상을 방지하고 효율적인 부하 분산을 제공합니다.

**3\. Block Engine**

* MEV 번들 처리의 핵심 의사 결정 레이어입니다.
* MEV 서처(searcher)와 트레이더로부터 트랜잭션 및 번들을 수신합니다.
* 오프체인에서 번들을 시뮬레이션하여 수익성(팁 크기와 컴퓨팅 효율성 기준)에 따라 우선순위를 결정합니다.
* 최적의 번들을 선택하여 검증자에게 원자적으로 전달합니다.

**4\. BundleStage (검증자 파이프라인)**

* 번들 내 모든 트랜잭션이 함께 성공하거나 실패하는 원자성(atomicity)을 보장합니다.
* 번들 내 트랜잭션의 엄격한 순차적 실행을 보장합니다.
* 번들과 관련된 계정을 락(lock)하여 다른 트랜잭션과의 충돌을 방지합니다.
* 표준 BankingStage와 통합되어 검증자의 트랜잭션 처리 파이프라인에 직접 연결됩니다.

**5\. Tip Payment Program (On-chain)**

* MEV 팁을 보관하는 일종의 “저금통” 역할을 합니다.  
* 서처는 팁(추가 lamport)을 사전에 정해진 PDA(프로그램 유도 계정, Program-Derived Accounts)에 예치합니다.  
* 팁의 안전한 관리 및 추적을 용이하게 합니다.

**6\. Tip Distribution Program (On-chain)**

* 스테이킹 비율에 따라 MEV 팁을 검증자와 스테이커에게 공정하게 분배합니다.  
* 각 에포크(epoch) 종료 시 머클 증명(Merkle proofs)을 사용하여 팁 분배를 검증 및 실행합니다.

## **상세한 트랜잭션 흐름**

**1\. 트랜잭션 제출 및 Relayer 버퍼링**

* 사용자의 트랜잭션이 **Relayer**를 통해 입력되고, MEV 번들 형성을 위해 약 200ms 동안 버퍼링됩니다.

**2\. 번들 형성 및 시뮬레이션**

* MEV 서처(searcher)가 최대 5개 트랜잭션을 묶은 번들을 **Block Engine**에 제출합니다.
* Block Engine은 오프체인에서 번들을 신속하게 시뮬레이션하여 수익성과 실행 가능성을 분석합니다.

**3\. 번들 경매(Bundle Auction)**

* Block Engine은 200ms마다 경매를 실시합니다.
* 번들의 우선순위는 두 가지 기준으로 결정됩니다: **제공된 팁(tip)의 크기**와 **컴퓨팅 유닛 당 효율성**.
* 동일한 계정에 액세스하는 번들은 함께 경매되고, 충돌이 없는 번들은 병렬 경매로 처리됩니다.

**4\. 검증자 실행(Validator Execution)**

* 경매에서 선정된 번들은 검증자의 **BlockEngineStage**로 전송된 후 **BundleStage 파이프라인**으로 이동합니다.
* 번들 내 트랜잭션은 지정된 순서대로 원자적으로 실행됩니다.
* 실행 과정 동안 관련 계정은 락(lock)되어 다른 트랜잭션의 액세스를 방지합니다.

**5\. 팁 수집(Tip Collection)**

* 실행된 번들의 팁(tip)이 **Tip Payment Program**에서 관리하는 PDA에 안전하게 저장됩니다.

**6\. 블록 생성 및 전파(Block Building)**

* 검증자는 MEV 번들과 일반 트랜잭션을 통합하여 블록을 구성합니다.
* 슬롯 시간의 초반 80%는 MEV 번들을 위한 공간이 우선 할당되며, 번들이 부족하면 남은 슬롯 시간은 일반 트랜잭션에 할당됩니다.
* 최종 완성된 블록은 솔라나 네트워크에 전파됩니다.

## **원자성(Atomicity) 및 번들 제약**

* 번들은 모든 트랜잭션이 함께 성공하거나 함께 실패하는 원자성을 보장해야 합니다.
* 번들은 단일 슬롯에서만 실행 가능하며, 컴퓨팅 유닛 한도 및 QoS 제약을 준수해야 합니다.
* 합의 메커니즘에 필수적인 계정(투표 계정, 게이트키 등)과의 충돌이 금지됩니다.

## **팁 지급 및 분배 메커니즘**

**현재 모델(중앙집중형)**

* 각 에포크에서 수집된 MEV 팁은 **팁 분배 계정(Tip Distribution Account, TDA)**에 집계됩니다.
* 팁 분배는 중앙에서 계산된 머클 루트(Merkle root)를 통해 관리되며, 스테이커는 이를 통해 보상을 청구합니다.

**미래 모델(분산형: Tip Rewards NCN)**

* 각 노드가 독립적으로 머클 루트를 계산하고 결과에 투표합니다.
* 네트워크 노드 2/3 이상의 합의가 이루어지면 팁 분배가 확정됩니다.
* 프로토콜 발전을 위한 DAO와 NCN 운영자를 위한 자동 공제(3%)가 포함됩니다.
* 분산화, 투명성, 보안성이 크게 개선됩니다.

**결론 및 영향**

* Jito는 현재 솔라나 수수료 수익의 약 2/3를 차지할 정도로 중요한 역할을 하고 있습니다.
* 솔라나 적극활성화(active stake)의 90% 이상이 Jito 클라이언트를 사용하며, 검증자 생태계와 네트워크 안정성에 핵심적인 역할을 하고 있습니다.
* Jito의 아키텍처(리레이어, 블록 엔진, 번들 스테이지, 팁 관리 프로그램 등)를 이해하는 것은 솔라나 생태계의 퍼포먼스와 거버넌스를 이해하는 데 필수적입니다.

# **5\. 옐로스톤 가이저(Yellowstone Geyser) & 실시간 데이터 스트리밍**

## **옐로스톤 가이저의 작동 원리**

* 검증자가 트랜잭션을 처리하고 계정 상태를 업데이트하면, 가이저(Geyser) 플러그인은 이러한 이벤트(토큰 전송, 스마트 컨트랙트 로그, 슬롯 완료 등)를 실시간으로 캡처합니다.  
* 이벤트는 드래곤스 마우스(Dragon’s Mouth) gRPC 인터페이스를 통해 외부 구독자에게 구조화된 데이터 스트림으로 전송됩니다.  
* 클라이언트는 특정 계정, 프로그램 또는 이벤트 타입에 대한 필터를 설정하여 필요한 데이터만 선택적으로 수신함으로써 네트워크 대역폭을 최적화할 수 있습니다.

## **개발자 및 dApp을 위한 이점**

* **실시간 데이터 처리**: DeFi 프로토콜, NFT 마켓플레이스, 트레이딩 서비스가 리얼타임 온체인 데이터에 접근할 수 있습니다.
* **선택적 구독**: 필요한 트랜잭션과 이벤트만 정확하게 필터링하여 수신할 수 있습니다.
* **자원 효율성**: 필요한 데이터만 스트리밍하여 인프라 비용과 시스템 리소스를 효율적으로 관리할 수 있습니다.

# **6\. 결론**

Solana의 **트랜잭션 라이프사이클**은 **사용자 → 걸프 스트림(Gulf Stream) → 블록 생성 → PoH → 터빈(Turbine) → 블록 검증 및 합의**로 이어지는 혁신적인 구성 요소들을 통해 **고속, 고처리량** 블록 생성을 실현합니다. Solana는 **메모리풀(mempool)을 제거**하고, **스테이크 가중 우선순위(stake-weighted prioritization)**를 적용하며, **실시간 데이터 활용** 을 통해 지연 시간, 혼잡, 병목 현상을 최소화합니다.

**옐로스톤 가이저(Yellowstone Geyser)**를 활용한 트랜잭션 스트리밍과 **SWQoS**, **Jito**, 또는 **Jito 대안 솔루션**을 통한 적절한 수수료 및 팁을 설정하면 사용자는 시장 기회를 빠르게 포착할 수 있습니다. 또한, **옐로스톤 가이저 노드까지의 거리**와 **SWQoS 및 Jito 서비스와의 인터넷 지연 시간**은 트랜잭션 속도와 실행 효율성에 큰 영향을 미치므로, 트레이더와 dApp 개발자에게 **네트워크 토폴로지** 가 중요한 요소가 됩니다.

올해 예정된 여러 가지 업데이트는 Solana의 성능과 사용자 경험을 더욱 향상시킬 것입니다. **Agave의 대규모 업그레이드**는 Greedy Scheduler 도입, CU 제한, 터빈 개선 등을 통해 네트워크 처리 효율과 속도를 획기적으로 높일 예정입니다. 또한 Q4에 도입될 예정인 **신형 합의 알고리즘** 은 체인 파이널리티를 크게 단축시켜 거래 체결 속도를 더욱 빠르게 만들어 줄 것으로 기대됩니다.

점프크립토가 준비 중인 **Firedancer 클라이언트**는 초당 최대 100만 건의 트랜잭션(TPS)을 처리하며 Solana의 성능을 획기적으로 높일 예정이며, 전담 고성능 네트워크 계층인 **Doublezero**의 도입으로 거래 처리량이 증가하고 지연 시간과 지터가 감소하여 밸리데이터 성능이 향상될 것입니다. 더불어 **APE(Asynchronous Program Execution)**는 프로그램 실행을 비동기로 처리하여 네트워크의 트랜잭션 병목 현상을 해소할 것이며, 4월 예정된 **Passkeys 네이티브 지원** 을 통해 비밀번호 없이 지문이나 페이스 ID로 웹3 로그인 UX가 대폭 개선될 것입니다.

이러한 지속적인 혁신과 최적화를 통해 Solana는 빠르고 확장 가능한 애플리케이션 개발을 위한 선도적인 블록체인으로 자리매김하며, 탈중앙화 시스템을 위한 최상급 인프라로서 Web3의 새로운 표준을 제시할 것입니다.
